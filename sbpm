#!/usr/bin/env bash

# simple bash (+git +coreutils) package manager
# for now can only download one thing at a time interactively
# github.com/rambile

# project name
PNAME="sbpm"
# project description
PDESC='A simple bash "package" manager'
# where to clone repos
DIR_CACHE="$HOME/.cache"
# data dir for project
DATA_DIR="$HOME/.local/share/$PNAME"
# store dir
STORE_DIR="$DATA_DIR/store"
# git clone args (submodules maybe?)
CLONE_ARGS="--depth 1"
# git pull args
PULL_ARGS=""
# default git repository host
HOST=github
# does the script save a file if it is in provides
NOSAVE=0

# distro specific
# AUR helper command
AURH="yay --answerdiff None --answerclean None --mflags "--noconfirm""

# create cache for git repo
mkdir -p $DIR_CACHE/$PNAME
PCACHE=$DIR_CACHE/$PNAME

# create store dir
mkdir -p $STORE_DIR

goAndDoPlease() { # $1 - dir to go to; $2 - a command to do there
    local goback=$(pwd)
    cd $1; $2
    cd $goback
}

hostExpansion() {
    case $1 in
        github)
            echo "https://github.com/$2"
    esac
}

dirName() { # $1 - author/repo, outputs "author repo"
    IFS='/' read -ra sepd <<< "$1"
    echo "${sepd[1]}@${sepd[0]}"
}

repoSync() { # $1 - package name in a format "author/repo"
    local CLONED_DIR="$PCACHE/$(dirName $1)"
    local HOST_EXPANDED=$(hostExpansion $HOST $1)
    local PACKAGE_DIR=$(getDirInStore $1)

    pretty stage "Sync"

    if ! [[ -d "$PACKAGE_DIR" ]]; then
        git clone $CLONE_ARGS $HOST_EXPANDED "$CLONED_DIR" || exit 1

        if ! [[ -e "$CLONED_DIR/rampkg" ]]; then
            pretty err2 "The repository does not contain rampkg file"
            cleanCache $1
            exit 1
        fi

        pretty info "Copying package from cache to store"
        cp -r "$CLONED_DIR" "$PACKAGE_DIR"
        cleanCache $1
    else
        removeLinks $1
        printf "Package already installed, updating instead\n"
        goAndDoPlease "$PACKAGE_DIR" "git pull $PULL_ARGS"
    fi
    afterSyncSetup $PACKAGE_DIR $1
}

getDirInStore() { # $1 - author/repo
    echo "$STORE_DIR/$(dirName $1)"
}

afterSyncSetup() { # $1 - a directory of a package in store, $2 - package name
    source "$1/rampkg"
    depCheckProxy
    linkProvides "$1"
    runSetup
}

depCheckProxy() {
    checkDistro

    #source $PCACHE/sbpm-tmp/dependencies
    pretty stage "Dependency check"
    pretty info "Checking dependencies"

    $distroDepcheckFunc
}

checkDistro() {
    # TODO this is not universal and works in most but not all distros
    distroName=$(grep '^NAME=' /etc/os-release | cut -d= -f2 | tr -d '"')

    case $distroName in
        "Arch Linux" | "smth else")
            distroDepcheckFunc=depCheckPacman
        ;;
        *)
            pretty err "Distro not supported yet. Or something did break."; exit 1
        ;;
    esac
}

depCheckPacman() {
    local err=()
    for dep in "${deplistPacman[@]}"; do
        if ! [[ $(pacman -Qq $dep 2> /dev/null) == "$dep" ]]; then
            pretty err2 "$dep not found"
            err+=("$dep")
        else
            pretty info2 "$dep found"
        fi
    done

    if ! [[ $err == "" ]]; then
        pretty err "\nDependencies are not satisfied\n"
        pretty info "Installing missing dependencies"
        $AURH -Sy "${err[@]}" # right now, as of yay v12.5.7, you cannot tell if the installation failed or not. This has been fixed 10 days after the release though. So it will continue no matter what, even if the dependencies do not work.
    else
        pretty info "Dependencies are satisfied"
    fi
}

runSetup() {
    pretty stage "Additional setup"
    pretty info "(If this does nothing then there is no setup)"
    SETUP
}

linkProvides() { # $1 - directory of a package in store
    pretty stage "Linking provides"
    pretty info "Checking if provides are present"

    if [[ "${provides[*]}" == "" ]]; then
        pretty info2 "The package does not provide any files by itself"
    else
        for dir in "${provides[@]}"; do
            IFS=':' read -ra sepd <<< "$dir"
            pretty info2 "Checking if there is already a file"
            if [[ -e ${sepd[1]} ]]; then
                pretty err2 "File already exists"
                if [[ $NOSAVE == 0 ]]; then
                    pretty info2 "Backing up file"
                    mkdir -p "$DATA_DIR/backup$(dirname ${sepd[1]})"
                    cp ${sepd[1]} "$DATA_DIR/backup$(dirname ${sepd[1]})"
                fi
            fi
            pretty info2 "Symlinking $1/${sepd[0]} to ${sepd[1]}"
            ln -sf $1/${sepd[0]} ${sepd[1]}
        done
    fi
}

removeLinks() { # $1 - package name
    pretty info "Removing links from $1 ($(dirName $1))"
    local PACKAGE_DIR=$(getDirInStore $1)
    source "$PACKAGE_DIR/rampkg"
    if [[ "${provides[*]}" == "" ]]; then
        pretty info "There are no links"
    else
        for dir in "${provides[@]}"; do
            IFS=':' read -ra sepd <<< "$dir" # [0] - file in store, [1] - destination dir
            pretty info2 "Removing link ${sepd[1]}"
            if [[ -h ${sepd[1]} ]]; then
                rm ${sepd[1]}
            else
                pretty err2 "The file is not a symlink or does not exist"
            fi
        done
    fi
}

cleanCache() { # $1 - author/repo
    if [[ -z ${1+x} ]]; then
        pretty info "Argument not given, cleaning all cache"
        rm -rf "$PCACHE"
    else
        if [[ -d "${PCACHE:?}/$(dirName $1)" ]]; then
            pretty info "cleaning $1 in cache"
            rm -rf "${PCACHE:?}/$(dirName $1)"
        else
            pretty err "No such package in cache"
        fi
    fi
}

deletePackage() { # $1 - author/repo
    # right now will delete only the package folder
    if [[ -d "$STORE_DIR/$(dirName $1)" ]]; then
        pretty info "Removing $1 from store ($STORE_DIR/$(dirName $1)/)"
        removeLinks $1
        rm -rf "${STORE_DIR:?}/$(dirName $1)"
    else
        pretty err "No such package in store"
    fi
}

getHelp() {
    printf "$(tgrn)$PNAME$(tclr) - $PDESC
Example usage: $(tgrn)$PNAME $(tclr)[ARGUMENTS] $(tprp)get $(tylw)<author/repo>$(tclr)
$(tgra)You should always use arguments before an option$(tclr)

Options:
    $(tprp)get $(tylw)<author/repo>$(tclr)    Syncs a given package from a default host (github) with backups of existing files
    $(tprp)del $(tylw)<author/repo>$(tclr)    Removes a package from store and deletes associated symlinks

Arguments:
    $(tprp)--branch $(tylw)<branch>$(tclr)    Specifies a branch to clone
    $(tprp)--clone-args $(tylw)<args>$(tclr)  Specifies arguments for git clone
    $(tprp)--host$(tylw)<host>$(tclr)         Specifies a host from which git will clone a repo
    -$(tprp)-nosave$(tylw)                    Does not backup files if there is already one in specified directory

Other:
    $(tprp)meow$(tclr)              Meow!
    $(tprp)help, -h, --help$(tclr)  Print this message
"
}

pretty() {
    case $1 in
        stage)
            printf "\n$(tprp)#############$(tclr)\n$(tprp)Running stage $(tclr)[$2]\n$(tprp)#############$(tclr)\n\n" >&2
        ;;
        info)
            printf "$(tgrn)==>$(tclr) $2\n" >&2
        ;;
        info2)
            printf "$(tgrn)   ==>$(tclr) $2\n" >&2
        ;;
        err)
            printf "$(tred)$2$(tclr)\n" >&2
        ;;
        err2)
            printf "$(tred)[E]==>$(tclr) $2\n" >&2
        ;;
    esac
}

tclr () { printf "\e[0;37;0m" ; }
tgra () { printf "\e[0;30;1m" ; }
tred () { printf "\e[0;31;1m" ; }
tgrn () { printf "\e[0;32;1m" ; }
tblu () { printf "\e[0;34;1m" ; }
tylw () { printf "\e[0;33;1m" ; }
tprp () { printf "\e[0;35;1m" ; }
tita () { printf "\e[3m" ; }

#removeLinks rambile/sbpm-test

POSITIONAL_ARGS=()
while [[ $# -gt 0 ]]; do
    case $1 in
        meow)
            echo meow!; exit 0
        ;;
        help | -h | --help)
            getHelp; exit 0
        ;;
        --host)
            HOST=$2; shift
        ;;
        --nosave)
            NOSAVE=1; shift
        ;;
        --clone-args)
            if [[ -z ${name+x} ]]; then
                pretty err 'Appending args is supported only in a string (i.e. "-q -b main")'
            fi
            CLONE_ARGS=$2; shift
        ;;
        --branch)
            CLONE_ARGS="$CLONE_ARGS -b $2"; shift
        ;;
        get)
            repoSync $2; shift
        ;;
        del)
            deletePackage $2; shift
        ;;
        -*)
            pretty err "Unknown option $1, check help (-h/--help/help)"; exit 1
        ;;
        *)
            POSITIONAL_ARGS+=("$1"); shift
        ;;
    esac
done
set -- "${POSITIONAL_ARGS[@]}"
